---
description: Architecture Patterns and Module Structure
globs: ["forester/**/*.py"]
alwaysApply: true
priority: 3
---

# Architecture Patterns

## Module Structure
```
forester/
├── core/          # Core functionality (database, storage, hashing, ignore rules)
├── models/        # Data models (Commit, Tree, Blob, Mesh)
├── commands/      # High-level commands (commit, branch, checkout, stash)
├── utils/         # Utility functions (filesystem, pattern matching, validation)
└── api.py         # Public Python API for automation
```

## Repository Path Resolution
- Use helper functions from `api.py`: `_get_repo_path()` or `_get_repo_path_or_none()`
- Pattern: `repo_path = find_repository(path) if not (path / ".DFM").exists() else path`
- Check for repository existence before operations
- Raise `ValueError` if repository required but not found

## Repository Operations
- Check repository existence before operations
- Raise `ValueError` if repository required but not found
- Return `None` or empty list for graceful failures when appropriate

## Database Operations (forester/core/database.py)
- Always use context manager: `with ForesterDB(db_path) as db:`
- Use `_unsafe` suffix for internal methods that assume connection exists
- Always call `self.conn.commit()` after write operations
- Use `exc_info=True` in exception handlers
- Handle `sqlite3.OperationalError` for database-specific errors

## File Operations
- Use `pathlib.Path` instead of `os.path`
- Check `path.exists()` before operations
- Use `relative_to()` for path manipulation
- Always handle `ValueError` from `relative_to()`
- Handle `OSError`, `PermissionError`, `ValueError` appropriately
- Log all file operation errors with context

## Data Models
- All models have `.hash` property (SHA-256)
- Models have `.save_to_storage()` and `.from_storage()` methods
- Use `@classmethod` for alternative constructors (e.g., `from_file()`, `from_directory()`)

## Mesh Export Operations
- **Background Export**: Mesh-only commits use background Blender process
  - Location: `operators/mesh_export_background.py` (background script)
  - Main function: `operators/mesh_io.py::_save_mesh_to_blend()`
  - Helper: `operators/mesh_io.py::get_empty_blend_path()`
  - Template: `empty_files/empty.blend`
- **Pattern**:
  ```python
  # 1. Save mesh data to temporary library
  bpy.data.libraries.write(str(temp_lib_path), data_blocks_to_save, fake_user=True)
  
  # 2. Run background Blender process
  subprocess.run([
      bpy.app.binary_path,
      '--background',
      '--python', str(script_path),
      '--',
      '--empty_blend', str(empty_blend_path),
      '--output_file', str(output_path),
      '--mesh_name', obj_name,
      '--library_file', str(temp_lib_path),
      # ... transform parameters
  ])
  ```
- **Benefits**: Current scene never modified, no restoration needed, better stability